/* Test program for communication of all data from sensors, and micro controller comms
 * with the main computer
 *
 * NOTE: This is using UART Serial protocol at a baud rate of 115200 with default
 *       8N1 format, which is 8 data bits, no parity, 1 stop bit
 *
 * NOTE: data form for motor speed:
 *                 l(+/-)###r(+/-)###
 *
 * TODO: Figure out how to get the RTIMU library linked up correctly
 */

#include "Com.h"

#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <cmath>
#include <string>

#include <unistd.h>
#include <sys/timeb.h>
#include <time.h>
#include <sys/time.h>

#include "rs232.h"
#include "IMUDrivers/RTIMU.h"
#include "RTIMULib.h"
#include "RTIMUSettings.h"

#define BUF_SIZE   128
#define PORT_NUM   24      // NOTE: using ttyACM0 -> port number 24
#define BAUDRATE   115200
#define TX_TIME    2000000 // usec -> 2 sec for stable condition
#define RX_TIME    100000  // waits for reply 100ms
#define CYCLE_TIME 100000  // sleep for 100ms


int main(int argc, char** argv){
  // IMU setup
  int sampleCount = 0;
  int sampleRate = 0;
  uint64_t rateTimer;
  uint64_t displayTimer;
  uint64_t now;

  //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
  //  Or, you can create the .ini in some other directory by using:
  //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
  //  where <directory path> is the path to where the .ini file is to be loaded/saved
  /*
  RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

  RTIMU *imu = RTIMU::createIMU(settings);

  if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)){
    printf("No IMU found\n");
    exit(1);
  }
  */

  imu->IMUInit();
  // change fusion parameters
  imu->setSlerpPower(0.02);
  imu->setGyroEnable(true);
  imu->setAccelEnable(true);
  imu->setCompassEnable(true);
  // setup for rate timer
  rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();


  // Communication TX & RX setup
  Com comms(BUF_SIZE, PORT_NUM, BAUDRATE);
  char mode[] = {'8', 'N', '1', 0}; // 8 data bits, no parity, 1 stop bit
  char str_send[1][BUF_SIZE];
  unsigned char str_recv[BUF_SIZE];

  if (RS232_OpenComport(PORT_NUM, BAUDRATE, mode, 0)){ // 0 is no flowctrl
    printf("Cannot open port\n");
    return 0;
  }
  usleep(TX_TIME);

  // MAIN LOOP
  for(int j = 0; j < 20; j++){ // NOTE: This would go on forever in the main loop
    // dummy velocity data
    comms.setSpd((rand() % (255 * 2 + 1) + (-255)), (rand() % (255 * 2 + 1) + (-255)));
    comms.formatData();

    // then put it into str_send
    strcpy(str_send[0], comms.data.c_str());

    //printf("Sending to mega: %s", str_send[0]);
    RS232_cputs(PORT_NUM, str_send[0]); // sends string on serial
    usleep(CYCLE_TIME);

    // gets chars from serial port (if any)
    int n = RS232_PollComport(PORT_NUM, str_recv, (int)BUF_SIZE);
    if(n > 0){
      str_recv[n] = 0; // always put a "null" at the end of a string
      //printf("Received %i bytes: %s\n", n, (char *)str_recv);
      std::string RX_data((char *)str_recv);
      comms.interpretRXData(RX_data);
    }
    usleep(CYCLE_TIME);
  }

  RS232_CloseComport(PORT_NUM);

  std::cout << "\n\nGot left encoder val: " << comms.getLeftEncoder() << std::endl;
  std::cout << "Got right encoder val:" << comms.getRightEncoder() << std::endl;
  std::cout << "Got usec time: " << comms.getTimeUsec() << std::endl;
  std::cout << "Got sec time: " << comms.getTimeSec() << std::endl;

  return 0;
}
